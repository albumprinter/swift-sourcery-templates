<%#
  A type erasure is a Swift-language pattern to combine both generic type parameters and associatedtypes, e.g.:
  ```swift
  protocol PresenterType {
    associatedtype Model
    func present(_ model: Model)
  }
  class TablePresenter<Model>: PresenterType {
    // ...
  }
  class CollectionPresenter<Model>: PresenterType {
    // ...
  }
  struct CarModel {}
  struct ShipModel {}
  let carPresenters = [AnyPresenter<CarModel>(TablePresenter()), AnyPresenter<CarModel>(CollectionPresenter())]
  let shipPresenters = [AnyPresenter<ShipModel>(TablePresenter()), AnyPresenter<ShipModel>(CollectionPresenter())]
  ```
  The pattern implemented here follows this article: https://www.bignerdranch.com/blog/breaking-down-type-erasures-in-swift/
-%>
<%- include("_header") -%>
<%- include("_utility") -%>
<%_
  let typesToProcess = types.protocols.filter { $0.annotations["TypeErase"] != nil }
  generateAdditionalImports(typesToProcess)

  for type in typesToProcess {
    let associatedTypes: [(associatedType: String, constraints: [String])] = extractAnnotations(type, annotationNames: ["associatedtype", "associatedtypes"])
      .map {
        let split = $0.replacingOccurrences(of: " ", with: "").characters.split(separator: ":").map(String.init)
        let associatedType = split[0]
        let constraints = split.count == 2 ? split[1].characters.split(separator: ",").map(String.init) : []
        return (associatedType: associatedType, constraints: constraints)
      }

    let associatedTypesList: String = associatedTypes.map { $0.associatedType }.joined(separator: ", ")
    let genericTypesConstraints: String = {
        let constraints = associatedTypes
          .flatMap {
            guard !$0.constraints.isEmpty else { return nil }
            let adopts = $0.constraints.joined(separator: ", ")
            return "\($0.associatedType): \(adopts)"
           }
          .joined(separator: ", ")
        return !constraints.isEmpty ? " where \(constraints)" : ""
    }()
-%>

// MARK: - Type erasure for `<%=type.name%>`

private class _Any<%=type.name%>Base<<%=associatedTypesList%>>: <%=type.name%><%=genericTypesConstraints%> {
    init() {
        guard type(of: self) != _Any<%=type.name%>Base.self else {
            fatalError("_Any<%=type.name%>Base<<%=associatedTypesList%>> instances can not be created; create a subclass instance instead")
        }
    }
    <%_ if !type.variables.isEmpty { -%>

    <%_ for p in type.variables { -%>
    var <%=p.name%>: <%=p.typeName%> {
        get { fatalError("Must override") }
        <% if p.isMutable { %>set { fatalError("Must override") }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !type.methods.isEmpty { -%>

    <%_ for m in type.methods { -%>
    func <%=m.name%> -> <%=m.returnTypeName%> {
        fatalError("Must override")
    }
    <%_ } -%>
    <%_ } -%>
}

private final class _Any<%=type.name%>Box<Concrete: <%=type.name%>>: _Any<%=type.name%>Base<<%=associatedTypes.map{"Concrete.\($0.associatedType)"}.joined(separator: ", ")%>> {
    private let concrete: Concrete
    <%_ for a in associatedTypes { -%>
    typealias <%=a.associatedType%> = Concrete.<%=a.associatedType%>
    <%_ } -%>

    init(_ concrete: Concrete) {
        self.concrete = concrete
    }
    <%_ if !type.variables.isEmpty { -%>

    <%_ for p in type.variables { -%>
    override var <%=p.name%>: <%=p.typeName%> {
        get { return concrete.<%=p.name%> }
        <% if p.isMutable { %>set { concrete.<%=p.name%> = newValue }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !type.methods.isEmpty { -%>

    <%_ for m in type.methods { -%>
    override func <%=m.name%> -> <%=m.returnTypeName%> {
        return concrete.<%=m.callName%>(<%= m.parameters.map { "\($0.argumentLabel ?? $0.name): \($0.`inout` ? "inout ": "")\($0.name)" }.joined(separator: ", ") %>)
    }
    <%_ } -%>
    <%_ } -%>
}

final class Any<%=type.name%><<%=associatedTypesList%>>: <%=type.name%><%=genericTypesConstraints%> {
    private let box: _Any<%=type.name%>Base<<%=associatedTypesList%>>

    init<Concrete: <%=type.name%>>(_ concrete: Concrete) where <%=associatedTypes.map {"Concrete.\($0.associatedType) == \($0.associatedType)"}.joined(separator: ", ")%> {
        self.box = _Any<%=type.name%>Box(concrete)
    }
    <%_ if !type.variables.isEmpty { -%>

    <%_ for p in type.variables { -%>
    override var <%=p.name%>: <%=p.typeName%> {
        get { return box.<%=p.name%> }
        <% if p.isMutable { %>set { box.<%=p.name%> = newValue }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !type.methods.isEmpty { -%>

    <%_ for m in type.methods { -%>
    func <%=m.name%> -> <%=m.returnTypeName%> {
        return box.<%=m.callName%>(<%= m.parameters.map { "\($0.argumentLabel ?? $0.name): \($0.`inout` ? "inout ": "")\($0.name)" }.joined(separator: ", ") %>)
    }
    <%_ } -%>
    <%_ } -%>
}
<%_ -%>
<% } -%>
