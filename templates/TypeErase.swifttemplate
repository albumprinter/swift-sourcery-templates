<%#
  A type erasure is a Swift-language pattern to combine both generic type parameters and associatedtypes, e.g.:
  ```swift
  protocol PresenterType {
    associatedtype Model
    func present(_ model: Model)
  }
  class TablePresenter<Model>: PresenterType {
    // ...
  }
  class CollectionPresenter<Model>: PresenterType {
    // ...
  }
  struct CarModel {}
  struct ShipModel {}
  let carPresenters = [AnyPresenter<CarModel>(TablePresenter()), AnyPresenter<CarModel>(CollectionPresenter())]
  let shipPresenters = [AnyPresenter<ShipModel>(TablePresenter()), AnyPresenter<ShipModel>(CollectionPresenter())]
  ```
  The pattern implemented here follows this article: https://www.bignerdranch.com/blog/breaking-down-type-erasures-in-swift/
-%>
<%- include("_header") -%>
<%- include("_utility") -%>
<%_
  let typesToProcess = types.protocols.filter { $0.annotations["TypeErase"] != nil }
  generateAdditionalImports(typesToProcess)

  for type in typesToProcess {
    let associatedTypes = extractAnnotations(type, annotationNames: ["associatedtype", "associatedtypes"])
    let associatedTypesList = associatedTypes.joined(separator: ", ")
-%>

// MARK: - Type erasure for `<%=type.name%>`

private class _Any<%=type.name%>Base<<%=associatedTypesList%>>: <%=type.name%> {
    init() {
        guard type(of: self) != _Any<%=type.name%>Base.self else {
            fatalError("_Any<%=type.name%>Base<<%=associatedTypesList%>> instances can not be created; create a subclass instance instead")
        }
    }
    <%_ if !type.variables.isEmpty { -%>

    <%_ for p in type.variables { -%>
    var <%=p.name%>: <%=p.typeName%> {
        get { fatalError("Must override") }
        <% if p.isMutable { %>set { fatalError("Must override") }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !type.methods.isEmpty { -%>

    <%_ for m in type.methods { -%>
    func <%=m.name%> -> <%=m.returnTypeName%> {
        fatalError("Must override")
    }
    <%_ } -%>
    <%_ } -%>
}

private final class _Any<%=type.name%>Box<Concrete: <%=type.name%>>: _Any<%=type.name%>Base<<%=associatedTypes.map{"Concrete.\($0)"}.joined(separator: ", ")%>> {
    private let concrete: Concrete
    <%_ for a in associatedTypes { -%>
    typealias <%=a%> = Concrete.<%=a%>
    <%_ } -%>

    init(_ concrete: Concrete) {
        self.concrete = concrete
    }
    <%_ if !type.variables.isEmpty { -%>

    <%_ for p in type.variables { -%>
    override var <%=p.name%>: <%=p.typeName%> {
        get { return concrete.<%=p.name%> }
        <% if p.isMutable { %>set { concrete.<%=p.name%> = newValue }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !type.methods.isEmpty { -%>

    <%_ for m in type.methods { -%>
    override func <%=m.name%> -> <%=m.returnTypeName%> {
        return concrete.<%=m.callName%>(<%= m.parameters.map { "\($0.argumentLabel ?? $0.name): \($0.`inout` ? "inout ": "")\($0.name)" }.joined(separator: ", ") %>)
    }
    <%_ } -%>
    <%_ } -%>
}

final class Any<%=type.name%><<%=associatedTypesList%>>: <%=type.name%> {
    private let box: _Any<%=type.name%>Base<<%=associatedTypesList%>>

    init<Concrete: <%=type.name%>>(_ concrete: Concrete) where <%=associatedTypes.map {"Concrete.\($0) == \($0)"}.joined(separator: ", ")%> {
        self.box = _Any<%=type.name%>Box(concrete)
    }
    <%_ if !type.variables.isEmpty { -%>

    <%_ for p in type.variables { -%>
    override var <%=p.name%>: <%=p.typeName%> {
        get { return box.<%=p.name%> }
        <% if p.isMutable { %>set { box.<%=p.name%> = newValue }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !type.methods.isEmpty { -%>

    <%_ for m in type.methods { -%>
    func <%=m.name%> -> <%=m.returnTypeName%> {
        return box.<%=m.callName%>(<%= m.parameters.map { "\($0.argumentLabel ?? $0.name): \($0.`inout` ? "inout ": "")\($0.name)" }.joined(separator: ", ") %>)
    }
    <%_ } -%>
    <%_ } -%>
}
<%_ -%>
<% } -%>
